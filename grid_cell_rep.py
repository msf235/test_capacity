"""
Test linear separability of manifolds generated by grid cell representaitons
of cyclic groups (i.e. the cyclic group of n elements Z_n written as
Z_n ≈ Z_n1 ⊕ Z_n2 ⊕ ... ⊕ Z_nm  where the integers nk are coprime and multiply
to be n). Here each of the Z_nk is a grid cell module.
"""
from sklearn import svm
import numpy as np
import itertools
from typing import Iterable
from matplotlib import pyplot as plt
randn = np.random.randn

def apply_g(g, x, mods): 
    """
    Apply the group element g (written as a tuple of integers) to the
    inputs x along the last dimension of x. Returns the permuted x.
    
    Parameters
    ---------
    g : tuple[int]
        The group element g, written as a tuple of integers where each entry
        specifies the number of shifts for the corresponding module.
    x : np.ndarray
        The data to apply the group action to. The group action is applied to
        the last dimension of x.
    mods : list[int]
        The size of the grid cell modules.

    """
    x = x.copy()
    prev = 0
    for i, gi in enumerate(g):
        rolled = np.roll(x[..., prev:mods[i]+prev], gi, axis=-1)
        x[..., prev:mods[i]+prev] = rolled
        prev = mods[i]
    return x

# %% Test group action
# Here we generate some data where the group action is easy to see.
X = np.zeros((10, 10))
X[:, 0] = 1
X[:, 4] = -1
X[:, 5] = 2
X[:, 8] = -2
X[:, 9] = 3
mods = (5, 4)
g = (2, 3)
Xp = apply_g(g, X, mods) 
# Now compare before group action to after group action
print(X[0]) # Before
print(Xp[0]) # After

# %% 

def get_manifolds_and_labels(ambient_dim, mods, nmans, seed=0):
    """
    Generate manifolds and labels.
    
    Parameters
    ----------
    ambient_dim : int
        The dimension of the ambient space containing the manifolds.
    mods : list[int]
        The size of the modules. Each entry corresponds with a module.
    nmans : int
        The number of manifolds to generate.
    
    Returns
    -------
    np.ndarray
        A numpy array containing the points for all the manifolds. It has
        shape (nmans, np.prod(mods), ambient_dim).
    np.ndarray
        A numpy array containing the labels (either 1. or 0.) for all possible
        dichotomies of the manifoldss. It has shape 
        (2**(nmans)-2, nmans, np.prod(mods)).
    """
    np.random.seed(seed)
    group_size = np.prod(mods)
    seed_pnts = randn(nmans, ambient_dim) # Initial points for the manifolds
    manifolds = np.zeros((nmans, group_size, ambient_dim))

    # We represent our group as a collection of tuples of integers.
    G = list(itertools.product(*[range(mod) for mod in mods]))

    for k1, g in enumerate(G):
        manifolds[:, k1] = apply_g(g, seed_pnts, mods)

    dichs = list(itertools.product(*[(0,1)]*nmans)) # All possible dichotomies
    # Remove the first and last dichotomies that assign every manifold the same
    # label.
    dichs.pop(0)
    dichs.pop()

    labels = np.zeros((2**nmans - 2, nmans, group_size))
    for k1, dich in enumerate(dichs):
        for k2, label in enumerate(dich):
            labels[k1, k2] = label
    return manifolds, labels

def nmans_linsep_loop(nmans_range: Iterable[int], ambient_dim : int,
                      mods : tuple[int]):
    """Loop through number of manifolds specified by nmans_range and test if
    these manifolds are linearly separable for all possible dichotomies.
    """
    for nmans in nmans_range: # todo: implement binary search
        manifolds, labels = get_manifolds_and_labels(ambient_dim, mods, nmans)
        X = manifolds.reshape(-1, ambient_dim)
        Y = labels.reshape(2**nmans-2, -1)
        for y in Y:
            fitter = svm.LinearSVC(tol=1e-10, max_iter=40000, C=10.)
            # fitter = svm.LinearSVC()
            fitter.fit(X, y)
            acc = fitter.score(X, y)
            if acc < 1.0:
                print()
                print('-----------------------')
                print("At least one dichotomy is not linearly separable")
                break
        if acc < 1.0:
            break
    print("The number of manifolds that are linearly separable for all "
          f"dichotomies is {nmans-1}.")
    return nmans-1, fitter


# %% Calculate the number of manifolds that can are linearly separable for all
# possible dichotomies.
# mods = (5, 4)
# ambient_dim = 9
# nmans_range = [2, 15] 
# nmans_linsep_loop(nmans_range, ambient_dim, mods)

mods = (5, 4)
ambient_dim = 11
nmans_range = np.arange(2, 15)
nsep_mans, fitter = nmans_linsep_loop(nmans_range, ambient_dim, mods)

# %% 
mods = (3, 2)
ambient_dim = 5
nmans = 4
manifolds, labels = get_manifolds_and_labels(ambient_dim, mods, nmans)
X = manifolds.reshape(-1, ambient_dim)
Y = labels.reshape(2**nmans-2, -1)
y = Y[5]
fitter = svm.LinearSVC(tol=1e-14, max_iter=40000, C=10.)
fitter.fit(X, y)
acc = fitter.score(X, y)

# %% 
mods = (3, 2)
ambient_dim = 5
nmans = 6
label_idx = 10
manifolds, labels = get_manifolds_and_labels(ambient_dim, mods, nmans)
mans_looped = np.concatenate([manifolds, manifolds[:, :1]], axis=1)
fig = plt.figure()
ax = plt.axes(projection='3d')
col = plt.cm.jet([0.2,.8])
for k in range(nmans):
    ax.plot(mans_looped[k, :, 0], mans_looped[k, :, 1], mans_looped[k, :, 2],
           color=col[int(labels[label_idx][k][0])])
    # ax.scatter(manifolds[k, :, 0], manifolds[k, :, 1], manifolds[k, :, 2],
              # c=labels[5][k])
fig.show()
fig, ax = plt.subplots()
for k in range(nmans):
    ax.plot(mans_looped[k, :, 3], mans_looped[k, :, 2],
            color=col[int(labels[label_idx][k][0])])
fig.show()

X = manifolds.reshape(-1, ambient_dim)
Y = labels.reshape(2**nmans-2, -1)
y = Y[label_idx]
fitter = svm.LinearSVC(tol=1e-14, max_iter=40000, C=10.)
fitter.fit(X, y)
acc = fitter.score(X, y)

nmans_range = [4, 6]
nsep_mans, fitter = nmans_linsep_loop(nmans_range, ambient_dim, mods)
# %% 
mods = (3,)
ambient_dim = 3
nmans = 2
manifolds, labels = get_manifolds_and_labels(ambient_dim, mods, nmans)
mans_looped = np.concatenate([manifolds, manifolds[:, :1]], axis=1)
fig = plt.figure()
ax = plt.axes(projection='3d')
for k in range(nmans):
    ax.plot(mans_looped[k, :, 0], mans_looped[k, :, 1], mans_looped[k, :, 2])
fig.show()
# pred_cap = 2**len(mods) - 1
