"""
Test linear separability of manifolds generated by grid cell representaitons
of cyclic groups (i.e. the cyclic group of n elements Z_n written as
Z_n ≈ Z_n1 ⊕ Z_n2 ⊕ ... ⊕ Z_nm  where the integers nk are coprime and multiply
to be n). Here each of the Z_nk corresponds with a grid cell module.
"""
from sklearn import svm, linear_model
import numpy as np
import itertools
from typing import Iterable
from matplotlib import pyplot as plt
randn = np.random.randn

def apply_g(g, x, mods): 
    """
    Apply the group element g (written as a tuple of integers) to the
    inputs x along the last dimension of x. Returns the permuted x.
    
    Parameters
    ---------
    g : tuple[int]
        The group element g, written as a tuple of integers where each entry
        specifies the number of shifts for the corresponding module.
    x : np.ndarray
        The data to apply the group action to. The group action is applied to
        the last dimension of x.
    mods : list[int]
        The size of the grid cell modules.

    """
    x = x.copy()
    prev = 0
    for i, gi in enumerate(g):
        rolled = np.roll(x[..., prev:mods[i]+prev], gi, axis=-1)
        x[..., prev:mods[i]+prev] = rolled
        prev = mods[i]
    return x

# %% Test group action
# Here we generate some data where the group action is easy to see.
X = np.zeros((10, 10))
X[:, 0] = 1
X[:, 4] = -1
X[:, 5] = 2
X[:, 8] = -2
X[:, 9] = 3
mods = (5, 4)
g = (2, 3)
Xp = apply_g(g, X, mods) 
# Now compare before group action to after group action
print(X[0]) # Before
print(Xp[0]) # After

# %% 

def get_manifolds_and_labels(ambient_dim, mods, nmans, seed=0):
    """
    Generate manifolds and labels.
    
    Parameters
    ----------
    ambient_dim : int
        The dimension of the ambient space containing the manifolds.
    mods : tuple[int]
        The size of the modules. Each entry corresponds with a module.
    nmans : int
        The number of manifolds to generate.
    seed : int
        Random number generator seed.
    
    Returns
    -------
    np.ndarray
        A numpy array containing the points for all the manifolds. It has
        shape (nmans, np.prod(mods), ambient_dim).
    np.ndarray
        A numpy array containing the labels (either 1. or 0.) for all possible
        dichotomies of the manifoldss. It has shape 
        (2**(nmans)-2, nmans, np.prod(mods)).
    """
    np.random.seed(seed)
    group_size = np.prod(mods)
    seed_pnts = randn(nmans, ambient_dim) # Initial points for the manifolds
    manifolds = np.zeros((nmans, group_size, ambient_dim))

    # We represent our group as a collection of tuples of integers.
    G = list(itertools.product(*[range(mod) for mod in mods]))

    for k1, g in enumerate(G):
        manifolds[:, k1] = apply_g(g, seed_pnts, mods)

    dichs = list(itertools.product(*[(0,1)]*nmans)) # All possible dichotomies
    # Remove the first and last dichotomies that assign every manifold the same
    # label.
    dichs.pop(0)
    dichs.pop()

    labels = np.zeros((2**nmans - 2, nmans, group_size))
    for k1, dich in enumerate(dichs):
        for k2, label in enumerate(dich):
            labels[k1, k2] = label
    return manifolds, labels

def nmans_linsep_loop(nmans_range: Iterable[int], ambient_dim : int,
                      mods : tuple[int]):
    """Loop through number of manifolds specified by nmans_range and test if
    these manifolds are linearly separable for all possible dichotomies.
    """
    for nmans in nmans_range: # todo: implement binary search
        manifolds, labels = get_manifolds_and_labels(ambient_dim, mods, nmans)
        X = manifolds.reshape(-1, ambient_dim)
        Y = labels.reshape(2**nmans-2, -1)
        # Y[Y==0] = -1
        for y in Y:
            fitter = svm.LinearSVC(tol=1e-12, max_iter=40000, C=30.)
            # fitter = linear_model.LogisticRegression(C=10., max_iter=40000,
                                                    # tol=1e-11)
            # fitter = svm.LinearSVC()
            fitter.fit(X, y)
            acc = fitter.score(X, y)
            if acc < 1.0:
                break
        if acc < 1.0:
            break
    print()
    print("The maximum number of manifolds that are linearly separable for all "
          f"dichotomies is {nmans-1}.")
    return nmans-1, fitter


# %% Calculate the number of manifolds that are linearly separable for all
# possible dichotomies.

mods = (5, 4)
ambient_dim = 9
nmans_range = np.arange(2, 15)
out = nmans_linsep_loop(nmans_range, ambient_dim, mods)

print()
print('-----------------')
print()
mods = (5, 4, 3)
ambient_dim = 12
nmans_range = np.arange(2, 15)
out = nmans_linsep_loop(nmans_range, ambient_dim, mods)
